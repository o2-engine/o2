# Архитектура движка

Архитектура делится на три слоя:

- верхний: сцена, акторы, компоненты, UI, редактор
- низкий: обёртка приложения, ассеты, рендер, анимации, ввод, физика, скрипты, звуки
- утилитарный: рефлексия и сериализация, менеджмент памяти, файловая система, отладка и логгирование, математика, делегаты, проперти, контейнеры данных, таймеры

Входная точка — это обёртка приложения (o2::Application), которая предоставляет кроссплатформенное API для управления приложением. Она имеет платформенные реализации для Windows, macOS, Linux, iOS, Android, Emscripten (WIP). Часть низкоуровневых и утилитарных систем (рендер, файловая система, таймеры) также имеют платформенные реализации. Все подсистемы оформлены как синглтоны для удобного доступа к ним.

Перед запуском приложения статически инициализируются некоторые утилитарные системы (например, менеджмент памяти, рефлексия). Затем при старте создаётся экземпляр приложения, который инициализирует остальные подсистемы, и после этого запускается игровой цикл.

Игровой цикл состоит из двух фаз: обновление и отрисовка. Всё выполняется внутри o2::Application::ProcessFrame, где обновляются система ввода, сцена, физика, вызывается рендер и т. д.

Разработчик может переопределить логику o2::Application, унаследовав собственный класс и реализовав там необходимые функции: инициализацию, запуск, отрисовку, обновление, сворачивание и разворачивание приложения.

## Утилитарный слой

Это базовые примитивы и подсистемы движка. Они используется во всем движке и являются основопологающими паттернами работы в нем

### Менеджмент памяти [(подробная документация)](/Docs/ru/Architecture/Utils/memory.md)

В движке используются собственные смарт-указатели, которые имеют внешний счётчик ссылок с внутренней ссылкой на него в самом объекте. Это даёт возможность преобразовывать обычный «сырой» указатель в умный, если объект унаследован от `RefCounterable`, хранящего в себе ссылку на счётчик. Для управления временем жизни используется сильная ссылка `Ref<>`, а для не влияющих на время жизни — слабая ссылка `WeakRef<>`. Объекты для умных указателей создаются только через функцию `mmake<T>(...)`, которая выделяет память под счётчик и объект одним блоком, чтобы счётчик всегда шёл перед объектом (cache-friendly). В режиме отладки в движке работает отладочный GC, указывающий на возможные утечки памяти и циклические ссылки, однако сам он объекты не уничтожает и служит лишь для анализа. В редакторе есть утилита для просмотра дерева памяти, где подсвечиваются проблемы. Кроме того, в движке предусмотрены специализированные ссылки для сериализации уникальных идентификаторов: `AssetRef` (для ассетов) и `LinkRef` (для акторов и компонентов).

<details>
<summary>Пример</summary>

```C++
class MyObject: o2::RefCounterable 
{};

Ref<MyObject> myObjectSample = mmake<MyObject>(...);
myObjectSample->DoSmth();

WeakRef<MyObject> myWeakObject = WeakRef(myObjectSample);

MyObject* rawObject = myObjectSample.Get();
Ref<MyObject> myObjectSample2 = Ref(rawObject);
```
</details>

### Рефлексия [(подробная документация)](/Docs/ru/Architecture/Utils/reflection.md)

Используется для доступа к структуре типов в рантайме (поиск анимируемых значений по строковому пути, вызов коллбеков по имени, сериализация/десериализация, автоматические биндинги скриптов). В основе лежит метаинформация о типах, генерируемая утилитой **o2CodeTool**. Она парсит заголовочные файлы (`.h`), находит в них классы C++ и анализирует их структуру (включая наследование). Затем определяет наследников `IObject` и в конце `.h` генерирует метаинформацию о типе. Эта метаинформация сохраняется в общий репозиторий и формируется инкрементально: кодогенератор хранит кэш проанализированных файлов и обновляет только те, что были изменены.

### Сериализация [(подробная документация)](/Docs/ru/Architecture/Utils/serialization.md)

Для внутреннего хранения данных используются форматы JSON и бинарный (в разработке). Данные представляются в виде `o2::DataValue` — структуры наподобие RapidJSON или PugiXML, позволяющей хранить массивы, таблицы или простые значения (числа, строки, логические и т. д.). Объект `o2::DataValue` может быть загружен из файла и преобразован в C++-объект, либо наоборот — объект сериализуется в `o2::DataValue` и сохраняется.

Сериализация осуществляется через рефлексию, а именно с помощью генерируемой метаинформации типов. В процессе сериализации специальный объект записывает данные в `o2::DataValue`. Для этого объект обязан унаследовать интерфейс `o2::ISerializable`, а поля, подлежащие сериализации, должны быть помечены атрибутом `@SERIALIZABLE`. Таким образом, сериализуются только необходимые типы и поля, включая примитивы, контейнеры и смарт-указатели.

### Проперти [(подробная документация)](/Docs/ru/Architecture/Utils/properties.md)

Проперти позволяют объявлять переменные, которые используют сеттер и геттер «под капотом», упрощая код. Вместо `object.SetValue(object.GetValue() + 200.0f);` можно писать `object.value += 200.0f;`, аналогично механизму свойств из C#.

Чтобы объявить проперти в классе, сначала ставится макрос `PROPERTIES(class_name)`. Затем для каждой проперти используется макрос `PROPERTY(type, name, setter, getter)`, где `setter` и `getter` — функции класса, обрабатывающие чтение и запись значения.

### Делегаты [(подробная документация)](/Docs/ru/Architecture/Utils/function.md)

`o2::Function<>` — это аналог `std::function<>` с расширенным функционалом, позволяющий хранить несколько делегатов одновременно. Такой подход упрощает систему подписок и событий в логике. Например, можно объявить в классе кнопки `o2::Function<void()> onClick;` и подписать на неё несколько обработчиков:

```cpp
myButton.onClick += []() { /* ... */ };
myButton.onClick += []() { /* ... */ };
myButton.onClick += []() { /* ... */ };
```

### Контейнеры данных [(подробная документация)](/Docs/ru/Architecture/Utils/containers.md)

Для удобства разработки в движке предусмотрены обёртки над стандартными контейнерами: o2::Vector<> и o2::Map<>. Они наследуются от соответствующих STL-контейнеров, дополняя их функциями, упрощающими синтаксис.

- **Модификация**: `Add(...)`, `Insert(...)`, `Remove(...)`, `RemoveAt(idx)`, `PopBack()`, `Clear()`.
- **Поиск**: `IndexOf(value)`, `Contains(value)`, `Find(...)`, `FindAll(...)`, `First()`, `Last()`.
- **Отбор**: `Where(...)`, `All(...)`, `Any(...)`, `Min(...) / Max(...)`
- **Сортировка**: `Sort(...)`, `SortBy(...)`, `Sorted(...)`.
- **Преобразование**: `Convert(...)`, `Cast()`, `DynamicCast()`, `Sum(...)`, `Reverse()`.
- **Итерация**: `ForEach(...)`, а также методы `Begin()`, `End()` для итераторов.

### Математика [(подробная документация)](/Docs/ru/Architecture/Utils/math.md)

В движке доступны функции классической и векторной математики внутри пространства имён `o2::Math`. Там же реализованы базовые структуры:  
- **`o2::Vec2F` / `o2::Vec2I`** — 2D-векторы (вещественные и целочисленные)  
- **`Basis`** — матрица 2×3 для 2D-трансформаций  
- **`o2::Curve`** — одномерная кривая Безье (график Y по X)  
- **`o2::Spline`** — двумерная кривая Безье с интерполяцией по длине  
- **`o2::Color4`** — цвет с RGBA  
- **`o2::Gradient`** — градиент  
- **`RectF` / `BorderF`** — прямоугольник и отступы  

Помимо этого, `o2::Math` предоставляет набор функций для тригонометрии, интерполяции и базовых операций.

### Файловая система [(подробная документация)](/Docs/ru/Architecture/Utils/filesystem.md)

В движке есть кроссплатформенная подсистема и обёртки для работы с файлами. Они позволяют открывать, читать, писать, перемещать, копировать и удалять файлы через удобный единый интерфейс, а также предоставляют дополнительные функции для работы с путями и расширениями.

### Логгирование [(подробная документация)](/Docs/ru/Architecture/Utils/logging.md)

В движке реализована система логирования с иерархией лог-стримов. Существует общий канал для всех логов и отдельные каналы (рендер, ассеты и др.). Пользователь может добавлять собственные каналы и настраивать родительскую иерархию, что даёт гибкую фильтрацию сообщений.

### Отладка [(подробная документация)](/Docs/ru/Architecture/Utils/debug.md)

Для удобной отладки игровой логики используется специальный интерфейс `o2Debug`. Он предоставляет простые функции для визуального дебага: отрисовка линий, прямоугольников, других геометрических фигур и текста.

## Низкий уровень

Набор отдельных подсистем по своему предназначению. Они образуют низкоуровневый фреймворк, с возможностью тонкой настройки и использования. Подсистемы верхнего уровня используют их как основу.

### Ассеты [(подробная документация)](/Docs/ru/Architecture/LowLevel/assets.md)

### обертка приложения [(подробная документация)](/Docs/ru/Architecture/LowLevel/application.md)
### ассеты [(подробная документация)](/Docs/ru/Architecture/LowLevel/assets.md)
### рендер [(подробная документация)](/Docs/ru/Architecture/LowLevel/render.md)
### анимации [(подробная документация)](/Docs/ru/Architecture/LowLevel/animations.md)
### обработка ввода [(подробная документация)](/Docs/ru/Architecture/LowLevel/input.md)
### физика [(подробная документация)](/Docs/ru/Architecture/LowLevel/physics.md)
### скрипты [(подробная документация)](/Docs/ru/Architecture/LowLevel/scripting.md)

## Высокий слой
- [сцена и акторы](/Docs/ru/Architecture/HighLevel/scene.md)
- [встроенные компоненты](/Docs/ru/Architecture/HighLevel/components.md)
- [UI](/Docs/ru/Architecture/HighLevel/ui.md)
