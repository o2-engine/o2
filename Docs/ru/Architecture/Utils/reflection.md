## Рефлексия

В движке используется собственная система типов. С помощью нее можно узнать параметры типа объекта в рантайме: размер, название, список полей и фукнций. Так это можно менять поля объекта по имени в рантайме, вызывать функции так же по имени. 

Так же поддерживаются аттрибуты для полей и функцийю. Они обозначаются в коде начиная с `@`, как правило в верхнем регистре. Например `@SERIALIZABLE`. Есть внутренние движковые аттрибуты, можно добавлять свои.

Изменять тип, добавлять новые поля или функции нельзя.

Рефлексия используется для сериализации и десериализации, поиска анимированных полей, генерации интерфейса редактора.

Концептуально все делится на 2 подсистемы: система типов и кодогенерация. Отдельная утилита, поставляемая вместе с движком, парсит заголовочные .h/.hpp файлы, ищет там классы которые должны быть отражены в рефлексии, и генерирует мета-код описания типа, который добавляет в конец заголовочного файла.

Выглядит это примерно так:
<details>
<summary>Пример мета-кода</summary>

```
// --- META ---

CLASS_BASES_META(Reel)
{
	BASE_CLASS(Component);
}
END_META;
CLASS_FIELDS_META(Reel)
{
	FIELD().PUBLIC().SERIALIZABLE_ATTRIBUTE().NAME(blurredImages);
	FIELD().PUBLIC().SERIALIZABLE_ATTRIBUTE().DEFAULT_VALUE(100.0f).NAME(imagesDistance);
	FIELD().PRIVATE().NAME(mImages);
	FIELD().PRIVATE().DEFAULT_VALUE(0.0f).NAME(mRotatingOffset);
}
END_META;
CLASS_METHODS_META(Reel)
{
	FUNCTION().PUBLIC().CONSTRUCTOR();
	FUNCTION().PRIVATE().SIGNATURE(void, OnDisabled);
	FUNCTION().PRIVATE().SIGNATURE(void, UpdateImagesLayout);
}
END_META;
// --- END META ---
```
</details>

Добавление в конец не особо мешает разработке, но является оптимальным вариантом для компиляции, в сравнении с выделением всего мета-кода в один большой файл. В такой файл подключается весь проект, и при любом изменении происходит долгая компиляция.

На основе сгенеренной мета-информации происходит инициализация типов на старте приложения, регистрация скриптованных типов, а так же сериализация в нужный момент.

### Система типов
Как бы странно ни звучало, у типа тоже есть подтипы. Базовым типом является `o2::Type`. Он хранит в себе базовую информацию о типе: название, размер, уникальный id, список базовых типов, список полей, список функций-членов и список статичных функций.

Для функций и полей хранится список аттрибутов, которые могут содержать мета-данные.

Кроме получения данных о типе, класс `o2::Type` дает дополнительный функционал:
- создание экземпляра объекта этого типа `CreateSample()`
- поиск указателя на поле по определенному. Поле может быть вложенным в подобъекты, тогда путь задается как путь к директории, с разделением слешами: `path/to/some/field`.
- получение прокси-структуры для поля этого типа. Эти проксти-структуры (`IAbstractValueProxy`) объединяют в себе разные подходы владения и изменения значением. Это может быть указатель на значение, либо пара функций setter/getter, либо значение из скрипта и тд
- сериализация/десериализация
- проверка на равенство. `IsValueEquals` получает на вход два `void*` на значения, внутри происходит автоматическая проверка
- копирование значения `CopyValue`

От базового `o2::Type` наследуются специализированные типы:
- `FunctionType` - функция-делегат `Function<>`
- `ObjectType` - объект. Имеет методы каста вверх и вниз относительно `IObject`
- `FundamentalType` - фундаментальный тип языка (int, float, string ...)
- `PointerType` - указатель на тип, может вернуть тип не-указатель
- `PropertyType` - тип для проперти
- `VectorType` - тип для `Vector<>`, может вернуть кол-во элементов и поинтер на определенный элемент по индексу
- `MapType` - тип для `Map<>`, может возвращать значения по ключам, список ключей
- `StringPointerAccessorType` -  тип для string pointer accessor, специальной обертки для перегрузки оператора `operator[](String& key)`
- `EnumType` - тип для enum'ов, позволяет получить список всех возможных значеный enum'а

### Аттрибуты
Для обозначения каких-то свойств полей или функций использутся аттрибуты. Они могут показывать сериализуется поле или нет, исключается или наоборот добавляется в редактор и тп. Можно создавать пользовательские аттрибуты.

Аттрибут задается специальным классом, унаследованным от `IAttribute` с внутренними макросами, обозначающими именование в коде и мета-информации.
```
ATTRIBUTE_COMMENT_DEFINITION("SERIALIZABLE");         // В коде тег будет читаться как @SERIALIZABLE
ATTRIBUTE_SHORT_DEFINITION("SERIALIZABLE_ATTRIBUTE"); // В мета-информацию будет добавлен как .SERIALIZABLE_ATTRIBUTE()
```

### Мета-код описания типов и его использование
Этот мета-код фактически является шаблонными функциями, инжектируемые в класс для которого строится тип. Он делится на 3 блока: список базовых классов, список полей и список функций. Каждый из этих блоков является шаблонной функцией.

В качестве шаблона задается специальный процессор типа наподобие `o2::BaseTypeProcessor`, в котором есть функции-обработчики записей о базовых классах, полях и методах.

Таким образом можно задать какой-то процессор типа объекта, который выполняет нужную функцию при переборе данных о типе.

Так происходит инициализация типов на старте. Кроме добавления в заголовочный файл мета-информации о типе, в исполняемые .cpp файлы автоматически добавляется регистрация типа, например `DECLARE_CLASS(Reel);`. Она инициирует регистрацию типа с определенным процессором. Этот процессор создает объект типа нужного типа (наследники от `o2::Type`) и заполняет его данными.

Так же с помощью этого процессора происходит сериализация и десериализация, о ней в отдельном разделе

### Подсистема рефлексии o2::Reflection
В движке есть класс-синглтон, отвечающий за систему рефлексии - `o2::Reflection`. Для более короткого доступа есть макрос `o2Reflection.`.

Через него можно получить список всех типов, создать экземпляр типа, получить тип по имени, сконвертировать enum в строку и обратно.

### Рефлексия объектов
Для того, чтобы класс был отражен в рефлексии, его нужно унаследовать от `o2::IObject` и разместить в теле класса макрос `IOBJECT(NAME_OF_CLASS)`. Этот макрос добавит нужные поля и функции в класс. Система кодогенерирования сама поймет эти признаки и сгенерирует мета-код

### Получение типа объекта
В классах, которые отражены в рефлексии, добавляется статичное полу `o2::Type* type`, в котором хранится тип класса. Так же добавляется **не статичный** метод `const o2::Type& GetType() const`, который в рантайме возвращает реальный тип объекта.

Так же доступен метод `TypeOf(value)`, который возвращает тип для любого значения value, которое туда передается. Это может быть как обхект, так и элементарный тип int, float, bool и др.
